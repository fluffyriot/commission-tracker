// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics_extended.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const getGlobalPostTypeAnalytics = `-- name: GetGlobalPostTypeAnalytics :many
SELECT
    post_type,
    count(*) as post_count,
    COALESCE(AVG(prh.likes), 0)::BIGINT as avg_likes
FROM posts p
JOIN sources s ON p.source_id = s.id
LEFT JOIN (
    SELECT DISTINCT ON (post_id) post_id, likes
    FROM posts_reactions_history
    ORDER BY post_id, synced_at DESC
) prh ON p.id = prh.post_id
WHERE s.user_id = $1
GROUP BY post_type
ORDER BY avg_likes DESC
`

type GetGlobalPostTypeAnalyticsRow struct {
	PostType  string `json:"post_type"`
	PostCount int64  `json:"post_count"`
	AvgLikes  int64  `json:"avg_likes"`
}

func (q *Queries) GetGlobalPostTypeAnalytics(ctx context.Context, userID uuid.UUID) ([]GetGlobalPostTypeAnalyticsRow, error) {
	rows, err := q.db.QueryContext(ctx, getGlobalPostTypeAnalytics, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalPostTypeAnalyticsRow
	for rows.Next() {
		var i GetGlobalPostTypeAnalyticsRow
		if err := rows.Scan(&i.PostType, &i.PostCount, &i.AvgLikes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHashtagAnalytics = `-- name: GetHashtagAnalytics :many
SELECT
    substring(word from 2) as tag,
    count(*) as usage_count,
    COALESCE(AVG(prh.likes), 0)::BIGINT as avg_likes,
    COALESCE(AVG(prh.views), 0)::BIGINT as avg_views
FROM (
    SELECT
        regexp_split_to_table(lower(content), '\s+') as word,
        posts.id as post_id
    FROM posts
    JOIN sources s ON posts.source_id = s.id
    WHERE s.user_id = $1
    AND content IS NOT NULL
) t
LEFT JOIN (
    SELECT DISTINCT ON (post_id) post_id, likes, views
    FROM posts_reactions_history
    ORDER BY post_id, synced_at DESC
) prh ON t.post_id = prh.post_id
WHERE word LIKE '#%' AND length(word) > 1
GROUP BY tag
ORDER BY usage_count DESC
LIMIT 20
`

type GetHashtagAnalyticsRow struct {
	Tag        interface{} `json:"tag"`
	UsageCount int64       `json:"usage_count"`
	AvgLikes   int64       `json:"avg_likes"`
	AvgViews   int64       `json:"avg_views"`
}

func (q *Queries) GetHashtagAnalytics(ctx context.Context, userID uuid.UUID) ([]GetHashtagAnalyticsRow, error) {
	rows, err := q.db.QueryContext(ctx, getHashtagAnalytics, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHashtagAnalyticsRow
	for rows.Next() {
		var i GetHashtagAnalyticsRow
		if err := rows.Scan(
			&i.Tag,
			&i.UsageCount,
			&i.AvgLikes,
			&i.AvgViews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMentionsAnalytics = `-- name: GetMentionsAnalytics :many
SELECT
    regexp_replace(substring(word from 2), '[^a-z0-9_.]', '', 'g') as mention,
    count(*) as usage_count,
    COALESCE(AVG(prh.likes), 0)::BIGINT as avg_likes
FROM (
    SELECT
        regexp_split_to_table(lower(content), '\s+') as word,
        posts.id as post_id
    FROM posts
    JOIN sources s ON posts.source_id = s.id
    WHERE s.user_id = $1
    AND content IS NOT NULL
) t
LEFT JOIN (
    SELECT DISTINCT ON (post_id) post_id, likes
    FROM posts_reactions_history
    ORDER BY post_id, synced_at DESC
) prh ON t.post_id = prh.post_id
WHERE word LIKE '@%'
GROUP BY mention
HAVING length(regexp_replace(substring(word from 2), '[^a-z0-9_.]', '', 'g')) > 1
ORDER BY avg_likes DESC
LIMIT 20
`

type GetMentionsAnalyticsRow struct {
	Mention    string `json:"mention"`
	UsageCount int64  `json:"usage_count"`
	AvgLikes   int64  `json:"avg_likes"`
}

func (q *Queries) GetMentionsAnalytics(ctx context.Context, userID uuid.UUID) ([]GetMentionsAnalyticsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMentionsAnalytics, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMentionsAnalyticsRow
	for rows.Next() {
		var i GetMentionsAnalyticsRow
		if err := rows.Scan(&i.Mention, &i.UsageCount, &i.AvgLikes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNetworkEfficiency = `-- name: GetNetworkEfficiency :many
SELECT
    s.network,
    count(*) as post_count,
    COALESCE(AVG(prh.likes), 0)::BIGINT as avg_likes,
    COALESCE(AVG(prh.reposts), 0)::BIGINT as avg_reposts
FROM posts p
JOIN sources s ON p.source_id = s.id
LEFT JOIN (
    SELECT DISTINCT ON (post_id) post_id, likes, reposts
    FROM posts_reactions_history
    ORDER BY post_id, synced_at DESC
) prh ON p.id = prh.post_id
WHERE s.user_id = $1
GROUP BY s.network
ORDER BY avg_likes DESC
`

type GetNetworkEfficiencyRow struct {
	Network    string `json:"network"`
	PostCount  int64  `json:"post_count"`
	AvgLikes   int64  `json:"avg_likes"`
	AvgReposts int64  `json:"avg_reposts"`
}

func (q *Queries) GetNetworkEfficiency(ctx context.Context, userID uuid.UUID) ([]GetNetworkEfficiencyRow, error) {
	rows, err := q.db.QueryContext(ctx, getNetworkEfficiency, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNetworkEfficiencyRow
	for rows.Next() {
		var i GetNetworkEfficiencyRow
		if err := rows.Scan(
			&i.Network,
			&i.PostCount,
			&i.AvgLikes,
			&i.AvgReposts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostingConsistency = `-- name: GetPostingConsistency :many
SELECT
    TO_CHAR(p.created_at, 'YYYY-MM-DD') as date_str,
    count(*) as post_count
FROM posts p
JOIN sources s ON p.source_id = s.id
WHERE s.user_id = $1
AND p.created_at > NOW() - INTERVAL '1 year'
GROUP BY date_str
ORDER BY date_str
`

type GetPostingConsistencyRow struct {
	DateStr   string `json:"date_str"`
	PostCount int64  `json:"post_count"`
}

func (q *Queries) GetPostingConsistency(ctx context.Context, userID uuid.UUID) ([]GetPostingConsistencyRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostingConsistency, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostingConsistencyRow
	for rows.Next() {
		var i GetPostingConsistencyRow
		if err := rows.Scan(&i.DateStr, &i.PostCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSiteStatsOverTime = `-- name: GetSiteStatsOverTime :many
SELECT date_str, total_visitors, avg_session_duration FROM (
    SELECT
        TO_CHAR(DATE_TRUNC('week', date), 'IYYY-"W"IW') as date_str,
        COALESCE(SUM(visitors), 0)::BIGINT as total_visitors,
        COALESCE(AVG(avg_session_duration), 0)::FLOAT as avg_session_duration
    FROM analytics_site_stats ass
    JOIN sources s ON ass.source_id = s.id
    WHERE s.user_id = $1
    GROUP BY DATE_TRUNC('week', date)
    ORDER BY DATE_TRUNC('week', date) DESC
    LIMIT 52
) recent_weeks
ORDER BY date_str ASC
`

type GetSiteStatsOverTimeRow struct {
	DateStr            string  `json:"date_str"`
	TotalVisitors      int64   `json:"total_visitors"`
	AvgSessionDuration float64 `json:"avg_session_duration"`
}

func (q *Queries) GetSiteStatsOverTime(ctx context.Context, userID uuid.UUID) ([]GetSiteStatsOverTimeRow, error) {
	rows, err := q.db.QueryContext(ctx, getSiteStatsOverTime, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSiteStatsOverTimeRow
	for rows.Next() {
		var i GetSiteStatsOverTimeRow
		if err := rows.Scan(&i.DateStr, &i.TotalVisitors, &i.AvgSessionDuration); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimePerformance = `-- name: GetTimePerformance :many
SELECT
    EXTRACT(DOW FROM p.created_at)::INT as day_of_week,
    EXTRACT(HOUR FROM p.created_at)::INT as hour_of_day,
    COALESCE(AVG(prh.likes), 0)::BIGINT as avg_likes
FROM posts p
JOIN sources s ON p.source_id = s.id
LEFT JOIN (
    SELECT DISTINCT ON (post_id) post_id, likes
    FROM posts_reactions_history
    ORDER BY post_id, synced_at DESC
) prh ON p.id = prh.post_id
WHERE s.user_id = $1
GROUP BY day_of_week, hour_of_day
ORDER BY day_of_week, hour_of_day
`

type GetTimePerformanceRow struct {
	DayOfWeek int32 `json:"day_of_week"`
	HourOfDay int32 `json:"hour_of_day"`
	AvgLikes  int64 `json:"avg_likes"`
}

func (q *Queries) GetTimePerformance(ctx context.Context, userID uuid.UUID) ([]GetTimePerformanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getTimePerformance, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTimePerformanceRow
	for rows.Next() {
		var i GetTimePerformanceRow
		if err := rows.Scan(&i.DayOfWeek, &i.HourOfDay, &i.AvgLikes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopPagesByViews = `-- name: GetTopPagesByViews :many
SELECT
    url_path,
    COALESCE(SUM(views), 0)::BIGINT as total_views
FROM analytics_page_stats aps
JOIN sources s ON aps.source_id = s.id
WHERE s.user_id = $1
GROUP BY url_path
ORDER BY total_views DESC
LIMIT 50
`

type GetTopPagesByViewsRow struct {
	UrlPath    string `json:"url_path"`
	TotalViews int64  `json:"total_views"`
}

func (q *Queries) GetTopPagesByViews(ctx context.Context, userID uuid.UUID) ([]GetTopPagesByViewsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopPagesByViews, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopPagesByViewsRow
	for rows.Next() {
		var i GetTopPagesByViewsRow
		if err := rows.Scan(&i.UrlPath, &i.TotalViews); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWordCloudData = `-- name: GetWordCloudData :many
SELECT
    cleaned_word as word,
    count(*) as count
FROM (
    SELECT regexp_replace(lower(regexp_split_to_table(content, '\s+')), '[^a-z0-9]', '', 'g') as cleaned_word,
           regexp_split_to_table(content, '\s+') as raw_word
    FROM posts
    JOIN sources s ON posts.source_id = s.id
    WHERE s.user_id = $1
    AND content IS NOT NULL
) t
WHERE length(cleaned_word) > 3
AND raw_word NOT LIKE '#%'
AND raw_word NOT LIKE '@%'
AND raw_word NOT LIKE 'http%'
AND raw_word NOT ILIKE '%http%'
AND raw_word NOT ILIKE '%www.%'
AND raw_word NOT ILIKE '%.com%'
AND cleaned_word NOT ILIKE '%iotpho%'
AND cleaned_word NOT IN (
    'that', 'have', 'with', 'this', 'from', 'they',  'will', 'would', 'there', 'their', 
    'about', 'which', 'when', 'make', 'like', 'time', 'just', 'know', 'take', 'what',
    'people', 'into', 'year', 'your', 'good', 'some', 'could', 'them', 'other', 'cant',
    'than', 'then', 'look', 'only', 'come', 'over', 'think', 'also', 'back', 'after', 
    'work', 'first', 'well', 'even', 'want', 'because', 'these', 'give', 'most',
    'were', 'been', 'here',  'many', 'dont', 'does', 'more', 'less'
)
GROUP BY cleaned_word
ORDER BY count DESC
LIMIT 50
`

type GetWordCloudDataRow struct {
	Word  string `json:"word"`
	Count int64  `json:"count"`
}

func (q *Queries) GetWordCloudData(ctx context.Context, userID uuid.UUID) ([]GetWordCloudDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getWordCloudData, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWordCloudDataRow
	for rows.Next() {
		var i GetWordCloudDataRow
		if err := rows.Scan(&i.Word, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
