// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics_engagement.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getCollaborationsData = `-- name: GetCollaborationsData :many
SELECT collaborator,
    COUNT(*) as collaboration_count,
    COALESCE(AVG(likes), 0)::BIGINT as avg_likes
FROM (
        SELECT p.author as collaborator,
            COALESCE(prh.likes, 0) as likes
        FROM posts p
            JOIN sources s ON p.source_id = s.id
            LEFT JOIN (
                SELECT DISTINCT ON (post_id) post_id,
                    likes
                FROM posts_reactions_history
                ORDER BY post_id,
                    synced_at DESC
            ) prh ON p.id = prh.post_id
        WHERE s.user_id = $1
            AND p.post_type IN ('repost', 'tag')
            AND p.author IS NOT NULL
            AND p.author != ''
    ) combined_collaborations
GROUP BY collaborator
ORDER BY avg_likes DESC
LIMIT 50
`

type GetCollaborationsDataRow struct {
	Collaborator       string `json:"collaborator"`
	CollaborationCount int64  `json:"collaboration_count"`
	AvgLikes           int64  `json:"avg_likes"`
}

func (q *Queries) GetCollaborationsData(ctx context.Context, userID uuid.UUID) ([]GetCollaborationsDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getCollaborationsData, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollaborationsDataRow
	for rows.Next() {
		var i GetCollaborationsDataRow
		if err := rows.Scan(&i.Collaborator, &i.CollaborationCount, &i.AvgLikes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEngagementRateData = `-- name: GetEngagementRateData :many
SELECT p.id,
    p.network_internal_id,
    p.created_at,
    s.network,
    COALESCE(prh.likes, 0)::BIGINT as likes,
    COALESCE(prh.reposts, 0)::BIGINT as reposts,
    COALESCE(ss.followers_count, 0)::BIGINT as followers_count
FROM posts p
    JOIN sources s ON p.source_id = s.id
    LEFT JOIN (
        SELECT DISTINCT ON (post_id) post_id,
            likes,
            reposts
        FROM posts_reactions_history
        ORDER BY post_id,
            synced_at DESC
    ) prh ON p.id = prh.post_id
    LEFT JOIN LATERAL (
        SELECT followers_count
        FROM sources_stats
        WHERE source_id = s.id
            AND date <= p.created_at
        ORDER BY date DESC
        LIMIT 1
    ) ss ON true
WHERE s.user_id = $1
    AND p.created_at > NOW() - INTERVAL '6 months'
    AND ss.followers_count > 0
`

type GetEngagementRateDataRow struct {
	ID                uuid.UUID `json:"id"`
	NetworkInternalID string    `json:"network_internal_id"`
	CreatedAt         time.Time `json:"created_at"`
	Network           string    `json:"network"`
	Likes             int64     `json:"likes"`
	Reposts           int64     `json:"reposts"`
	FollowersCount    int64     `json:"followers_count"`
}

func (q *Queries) GetEngagementRateData(ctx context.Context, userID uuid.UUID) ([]GetEngagementRateDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getEngagementRateData, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEngagementRateDataRow
	for rows.Next() {
		var i GetEngagementRateDataRow
		if err := rows.Scan(
			&i.ID,
			&i.NetworkInternalID,
			&i.CreatedAt,
			&i.Network,
			&i.Likes,
			&i.Reposts,
			&i.FollowersCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowRatioData = `-- name: GetFollowRatioData :many
SELECT s.network,
    s.user_name,
    COALESCE(ss.followers_count, 0)::BIGINT as followers_count,
    COALESCE(ss.following_count, 0)::BIGINT as following_count
FROM sources s
    JOIN LATERAL (
        SELECT followers_count,
            following_count
        FROM sources_stats
        WHERE source_id = s.id
        ORDER BY date DESC
        LIMIT 1
    ) ss ON true
WHERE s.user_id = $1
    AND ss.followers_count > 0
    AND ss.following_count > 0
`

type GetFollowRatioDataRow struct {
	Network        string `json:"network"`
	UserName       string `json:"user_name"`
	FollowersCount int64  `json:"followers_count"`
	FollowingCount int64  `json:"following_count"`
}

func (q *Queries) GetFollowRatioData(ctx context.Context, userID uuid.UUID) ([]GetFollowRatioDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getFollowRatioData, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFollowRatioDataRow
	for rows.Next() {
		var i GetFollowRatioDataRow
		if err := rows.Scan(
			&i.Network,
			&i.UserName,
			&i.FollowersCount,
			&i.FollowingCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalPostTypeAnalytics = `-- name: GetGlobalPostTypeAnalytics :many
SELECT post_type,
    count(*) as post_count,
    COALESCE(AVG(prh.likes), 0)::BIGINT as avg_likes
FROM posts p
    JOIN sources s ON p.source_id = s.id
    LEFT JOIN (
        SELECT DISTINCT ON (post_id) post_id,
            likes
        FROM posts_reactions_history
        ORDER BY post_id,
            synced_at DESC
    ) prh ON p.id = prh.post_id
WHERE s.user_id = $1
GROUP BY post_type
ORDER BY avg_likes DESC
`

type GetGlobalPostTypeAnalyticsRow struct {
	PostType  string `json:"post_type"`
	PostCount int64  `json:"post_count"`
	AvgLikes  int64  `json:"avg_likes"`
}

func (q *Queries) GetGlobalPostTypeAnalytics(ctx context.Context, userID uuid.UUID) ([]GetGlobalPostTypeAnalyticsRow, error) {
	rows, err := q.db.QueryContext(ctx, getGlobalPostTypeAnalytics, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalPostTypeAnalyticsRow
	for rows.Next() {
		var i GetGlobalPostTypeAnalyticsRow
		if err := rows.Scan(&i.PostType, &i.PostCount, &i.AvgLikes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMentionsAnalytics = `-- name: GetMentionsAnalytics :many
SELECT regexp_replace(
        substring(
            word
            from 2
        ),
        '[^a-z0-9_.]',
        '',
        'g'
    ) as mention,
    count(*) as usage_count,
    COALESCE(AVG(prh.likes), 0)::BIGINT as avg_likes
FROM (
        SELECT regexp_split_to_table(lower(content), '\s+') as word,
            posts.id as post_id
        FROM posts
            JOIN sources s ON posts.source_id = s.id
        WHERE s.user_id = $1
            AND content IS NOT NULL
    ) t
    LEFT JOIN (
        SELECT DISTINCT ON (post_id) post_id,
            likes
        FROM posts_reactions_history
        ORDER BY post_id,
            synced_at DESC
    ) prh ON t.post_id = prh.post_id
WHERE word LIKE '@%'
GROUP BY mention
HAVING length(
        regexp_replace(
            substring(
                word
                from 2
            ),
            '[^a-z0-9_.]',
            '',
            'g'
        )
    ) > 1
ORDER BY avg_likes DESC
LIMIT 20
`

type GetMentionsAnalyticsRow struct {
	Mention    string `json:"mention"`
	UsageCount int64  `json:"usage_count"`
	AvgLikes   int64  `json:"avg_likes"`
}

func (q *Queries) GetMentionsAnalytics(ctx context.Context, userID uuid.UUID) ([]GetMentionsAnalyticsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMentionsAnalytics, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMentionsAnalyticsRow
	for rows.Next() {
		var i GetMentionsAnalyticsRow
		if err := rows.Scan(&i.Mention, &i.UsageCount, &i.AvgLikes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNetworkEfficiency = `-- name: GetNetworkEfficiency :many
SELECT s.network,
    count(*) as post_count,
    COALESCE(AVG(prh.likes), 0)::BIGINT as avg_likes,
    COALESCE(AVG(prh.reposts), 0)::BIGINT as avg_reposts
FROM posts p
    JOIN sources s ON p.source_id = s.id
    LEFT JOIN (
        SELECT DISTINCT ON (post_id) post_id,
            likes,
            reposts
        FROM posts_reactions_history
        ORDER BY post_id,
            synced_at DESC
    ) prh ON p.id = prh.post_id
WHERE s.user_id = $1
GROUP BY s.network
ORDER BY avg_likes DESC
`

type GetNetworkEfficiencyRow struct {
	Network    string `json:"network"`
	PostCount  int64  `json:"post_count"`
	AvgLikes   int64  `json:"avg_likes"`
	AvgReposts int64  `json:"avg_reposts"`
}

func (q *Queries) GetNetworkEfficiency(ctx context.Context, userID uuid.UUID) ([]GetNetworkEfficiencyRow, error) {
	rows, err := q.db.QueryContext(ctx, getNetworkEfficiency, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNetworkEfficiencyRow
	for rows.Next() {
		var i GetNetworkEfficiencyRow
		if err := rows.Scan(
			&i.Network,
			&i.PostCount,
			&i.AvgLikes,
			&i.AvgReposts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
