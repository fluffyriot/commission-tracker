// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dashboard_stats.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getActiveSourcesCount = `-- name: GetActiveSourcesCount :one
SELECT COUNT(*)
FROM sources
where is_active = TRUE
    and user_id = $1
`

func (q *Queries) GetActiveSourcesCount(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getActiveSourcesCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getActiveTargetsCount = `-- name: GetActiveTargetsCount :one
SELECT COUNT(*)
FROM targets
where is_active = TRUE
    and user_id = $1
`

func (q *Queries) GetActiveTargetsCount(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getActiveTargetsCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRestTopSources = `-- name: GetRestTopSources :many
SELECT s.id,
    s.user_name,
    s.network,
    SUM(
        COALESCE(prh.likes, 0) + COALESCE(prh.reposts, 0)
    )::BIGINT AS total_interactions,
    SUM(COALESCE(prh.views, 0))::BIGINT AS total_views,
    COALESCE(
        (
            SELECT ss.followers_count
            FROM sources_stats ss
            WHERE ss.source_id = s.id
            ORDER BY ss.date DESC
            LIMIT 1
        ), 0
    )::BIGINT AS followers_count
FROM sources s
    LEFT JOIN posts p ON s.id = p.source_id
    LEFT JOIN (
        SELECT DISTINCT ON (post_id) post_id,
            likes,
            reposts,
            views
        FROM posts_reactions_history
        ORDER BY post_id,
            synced_at DESC
    ) prh ON p.id = prh.post_id
WHERE s.user_id = $1
    AND s.is_active = TRUE
    AND NOT s.network in ('Google Analytics')
GROUP BY s.id
ORDER BY total_interactions DESC OFFSET 3
`

type GetRestTopSourcesRow struct {
	ID                uuid.UUID `json:"id"`
	UserName          string    `json:"user_name"`
	Network           string    `json:"network"`
	TotalInteractions int64     `json:"total_interactions"`
	TotalViews        int64     `json:"total_views"`
	FollowersCount    int64     `json:"followers_count"`
}

func (q *Queries) GetRestTopSources(ctx context.Context, userID uuid.UUID) ([]GetRestTopSourcesRow, error) {
	rows, err := q.db.QueryContext(ctx, getRestTopSources, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRestTopSourcesRow
	for rows.Next() {
		var i GetRestTopSourcesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserName,
			&i.Network,
			&i.TotalInteractions,
			&i.TotalViews,
			&i.FollowersCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopSources = `-- name: GetTopSources :many
SELECT s.id,
    s.user_name,
    s.network,
    SUM(
        COALESCE(prh.likes, 0) + COALESCE(prh.reposts, 0)
    )::BIGINT AS total_interactions,
    SUM(COALESCE(prh.views, 0))::BIGINT AS total_views,
    COALESCE(
        (
            SELECT ss.followers_count
            FROM sources_stats ss
            WHERE ss.source_id = s.id
            ORDER BY ss.date DESC
            LIMIT 1
        ), 0
    )::BIGINT AS followers_count
FROM sources s
    LEFT JOIN posts p ON s.id = p.source_id
    LEFT JOIN (
        SELECT DISTINCT ON (post_id) post_id,
            likes,
            reposts,
            views
        FROM posts_reactions_history
        ORDER BY post_id,
            synced_at DESC
    ) prh ON p.id = prh.post_id
WHERE s.user_id = $1
    AND s.is_active = TRUE
    AND NOT s.network in ('Google Analytics')
GROUP BY s.id
ORDER BY total_interactions DESC
LIMIT 3
`

type GetTopSourcesRow struct {
	ID                uuid.UUID `json:"id"`
	UserName          string    `json:"user_name"`
	Network           string    `json:"network"`
	TotalInteractions int64     `json:"total_interactions"`
	TotalViews        int64     `json:"total_views"`
	FollowersCount    int64     `json:"followers_count"`
}

func (q *Queries) GetTopSources(ctx context.Context, userID uuid.UUID) ([]GetTopSourcesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopSources, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSourcesRow
	for rows.Next() {
		var i GetTopSourcesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserName,
			&i.Network,
			&i.TotalInteractions,
			&i.TotalViews,
			&i.FollowersCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalDailyEngagementStats = `-- name: GetTotalDailyEngagementStats :many
SELECT calendar.date::date as period_date,
    COALESCE(
        (
            SELECT SUM(
                    COALESCE(likes, 0) + COALESCE(reposts, 0)
                )
            FROM (
                    SELECT DISTINCT ON (prh.post_id) prh.likes,
                        prh.reposts
                    FROM posts_reactions_history prh
                        JOIN posts p ON prh.post_id = p.id
                        JOIN sources s ON p.source_id = s.id
                    WHERE s.user_id = $1
                        AND prh.synced_at < calendar.date + INTERVAL '1 day'
                    ORDER BY prh.post_id,
                        prh.synced_at DESC
                ) as distinct_posts
        ),
        0
    )::BIGINT as total_engagement
FROM generate_series(
        date_trunc('day', $2::timestamp),
        date_trunc('day', $3::timestamp),
        '1 day'::interval
    ) as calendar (date)
ORDER BY calendar.date ASC
`

type GetTotalDailyEngagementStatsParams struct {
	UserID  uuid.UUID `json:"user_id"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
}

type GetTotalDailyEngagementStatsRow struct {
	PeriodDate      time.Time `json:"period_date"`
	TotalEngagement int64     `json:"total_engagement"`
}

func (q *Queries) GetTotalDailyEngagementStats(ctx context.Context, arg GetTotalDailyEngagementStatsParams) ([]GetTotalDailyEngagementStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTotalDailyEngagementStats, arg.UserID, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalDailyEngagementStatsRow
	for rows.Next() {
		var i GetTotalDailyEngagementStatsRow
		if err := rows.Scan(&i.PeriodDate, &i.TotalEngagement); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalDailyFollowerStats = `-- name: GetTotalDailyFollowerStats :many
SELECT calendar.date::date as period_date,
    COALESCE(
        (
            SELECT SUM(COALESCE(followers_count, 0))
            FROM (
                    SELECT DISTINCT ON (ss.source_id) ss.followers_count
                    FROM sources_stats ss
                        JOIN sources s ON ss.source_id = s.id
                    WHERE s.user_id = $1
                        AND ss.date < calendar.date + INTERVAL '1 day'
                    ORDER BY ss.source_id,
                        ss.date DESC
                ) as distinct_sources
        ),
        0
    )::BIGINT as total_followers
FROM generate_series(
        date_trunc('day', $2::timestamp),
        date_trunc('day', $3::timestamp),
        '1 day'::interval
    ) as calendar (date)
ORDER BY calendar.date ASC
`

type GetTotalDailyFollowerStatsParams struct {
	UserID  uuid.UUID `json:"user_id"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
}

type GetTotalDailyFollowerStatsRow struct {
	PeriodDate     time.Time `json:"period_date"`
	TotalFollowers int64     `json:"total_followers"`
}

func (q *Queries) GetTotalDailyFollowerStats(ctx context.Context, arg GetTotalDailyFollowerStatsParams) ([]GetTotalDailyFollowerStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTotalDailyFollowerStats, arg.UserID, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalDailyFollowerStatsRow
	for rows.Next() {
		var i GetTotalDailyFollowerStatsRow
		if err := rows.Scan(&i.PeriodDate, &i.TotalFollowers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalPostsCount = `-- name: GetTotalPostsCount :one
SELECT COUNT(*)
FROM posts
    left join sources on posts.source_id = sources.id
where sources.user_id = $1
`

func (q *Queries) GetTotalPostsCount(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalPostsCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalReactions = `-- name: GetTotalReactions :one
SELECT COALESCE(SUM(likes), 0)::BIGINT AS total_likes,
    COALESCE(SUM(reposts), 0)::BIGINT AS total_shares,
    COALESCE(SUM(views), 0)::BIGINT AS total_views
FROM (
        SELECT DISTINCT ON (prh.post_id) prh.likes,
            prh.reposts,
            prh.views
        FROM posts_reactions_history prh
            left join posts p on prh.post_id = p.id
            left join sources s on p.source_id = s.id
        where s.user_id = $1
        ORDER BY prh.post_id,
            prh.synced_at DESC
    ) AS latest_reactions
`

type GetTotalReactionsRow struct {
	TotalLikes  int64 `json:"total_likes"`
	TotalShares int64 `json:"total_shares"`
	TotalViews  int64 `json:"total_views"`
}

func (q *Queries) GetTotalReactions(ctx context.Context, userID uuid.UUID) (GetTotalReactionsRow, error) {
	row := q.db.QueryRowContext(ctx, getTotalReactions, userID)
	var i GetTotalReactionsRow
	err := row.Scan(&i.TotalLikes, &i.TotalShares, &i.TotalViews)
	return i, err
}
