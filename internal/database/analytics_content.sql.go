// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics_content.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getEngagementVelocityData = `-- name: GetEngagementVelocityData :many
SELECT prh.post_id,
    prh.synced_at as history_synced_at,
    COALESCE(prh.likes, 0)::BIGINT as likes,
    COALESCE(prh.reposts, 0)::BIGINT as reposts,
    p.created_at as post_created_at,
    COALESCE(p.content, '')::TEXT as content,
    p.author,
    p.network_internal_id,
    s.network
FROM posts_reactions_history prh
    JOIN posts p ON prh.post_id = p.id
    JOIN sources s ON p.source_id = s.id
    JOIN (
        SELECT post_id,
            MIN(synced_at) as first_synced
        FROM posts_reactions_history
        GROUP BY post_id
    ) first_sync ON p.id = first_sync.post_id
WHERE s.user_id = $1
    AND p.created_at > NOW() - INTERVAL '30 days'
    AND p.post_type NOT IN ('tag', 'repost', 'quote')
    AND DATE(p.created_at) = DATE(first_sync.first_synced)
ORDER BY prh.post_id,
    prh.synced_at ASC
`

type GetEngagementVelocityDataRow struct {
	PostID            uuid.UUID `json:"post_id"`
	HistorySyncedAt   time.Time `json:"history_synced_at"`
	Likes             int64     `json:"likes"`
	Reposts           int64     `json:"reposts"`
	PostCreatedAt     time.Time `json:"post_created_at"`
	Content           string    `json:"content"`
	Author            string    `json:"author"`
	NetworkInternalID string    `json:"network_internal_id"`
	Network           string    `json:"network"`
}

func (q *Queries) GetEngagementVelocityData(ctx context.Context, userID uuid.UUID) ([]GetEngagementVelocityDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getEngagementVelocityData, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEngagementVelocityDataRow
	for rows.Next() {
		var i GetEngagementVelocityDataRow
		if err := rows.Scan(
			&i.PostID,
			&i.HistorySyncedAt,
			&i.Likes,
			&i.Reposts,
			&i.PostCreatedAt,
			&i.Content,
			&i.Author,
			&i.NetworkInternalID,
			&i.Network,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHashtagAnalytics = `-- name: GetHashtagAnalytics :many
SELECT lower(matches [1]) as tag,
    count(*) as usage_count,
    COALESCE(AVG(prh.likes), 0)::BIGINT as avg_likes,
    COALESCE(AVG(prh.views), 0)::BIGINT as avg_views
FROM (
        SELECT regexp_matches(content, '#([[:alnum:]_]+)', 'g') as matches,
            posts.id as post_id
        FROM posts
            JOIN sources s ON posts.source_id = s.id
        WHERE s.user_id = $1
            AND content IS NOT NULL
    ) t
    LEFT JOIN (
        SELECT DISTINCT ON (post_id) post_id,
            likes,
            views
        FROM posts_reactions_history
        ORDER BY post_id,
            synced_at DESC
    ) prh ON t.post_id = prh.post_id
GROUP BY tag
ORDER BY avg_likes DESC
LIMIT 20
`

type GetHashtagAnalyticsRow struct {
	Tag        string `json:"tag"`
	UsageCount int64  `json:"usage_count"`
	AvgLikes   int64  `json:"avg_likes"`
	AvgViews   int64  `json:"avg_views"`
}

func (q *Queries) GetHashtagAnalytics(ctx context.Context, userID uuid.UUID) ([]GetHashtagAnalyticsRow, error) {
	rows, err := q.db.QueryContext(ctx, getHashtagAnalytics, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHashtagAnalyticsRow
	for rows.Next() {
		var i GetHashtagAnalyticsRow
		if err := rows.Scan(
			&i.Tag,
			&i.UsageCount,
			&i.AvgLikes,
			&i.AvgViews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPerformanceDeviationData = `-- name: GetPerformanceDeviationData :many
WITH SourceAverages AS (
    SELECT p.source_id,
        AVG(
            COALESCE(prh.likes, 0) + COALESCE(prh.reposts, 0)
        ) as avg_engagement
    FROM posts p
        LEFT JOIN (
            SELECT DISTINCT ON (post_id) post_id,
                likes,
                reposts
            FROM posts_reactions_history
            ORDER BY post_id,
                synced_at DESC
        ) prh ON p.id = prh.post_id
    GROUP BY p.source_id
)
SELECT p.id,
    p.network_internal_id,
    COALESCE(p.content, '')::TEXT as content,
    p.created_at,
    p.author,
    s.network,
    COALESCE(prh.likes, 0)::BIGINT as likes,
    COALESCE(prh.reposts, 0)::BIGINT as reposts,
    (
        sa.avg_engagement * LEAST(
            1.0,
            EXTRACT(
                EPOCH
                FROM (NOW() - p.created_at)
            ) / 86400.0
        )
    )::FLOAT as expected_engagement
FROM posts p
    JOIN sources s ON p.source_id = s.id
    JOIN SourceAverages sa ON p.source_id = sa.source_id
    LEFT JOIN (
        SELECT DISTINCT ON (post_id) post_id,
            likes,
            reposts
        FROM posts_reactions_history
        ORDER BY post_id,
            synced_at DESC
    ) prh ON p.id = prh.post_id
WHERE s.user_id = $1
    AND p.post_type NOT IN ('tag', 'repost', 'quote')
ORDER BY ABS(
        (
            COALESCE(prh.likes, 0) + COALESCE(prh.reposts, 0)
        ) - (
            sa.avg_engagement * LEAST(
                1.0,
                EXTRACT(
                    EPOCH
                    FROM (NOW() - p.created_at)
                ) / 86400.0
            )
        )
    ) DESC
LIMIT 100
`

type GetPerformanceDeviationDataRow struct {
	ID                 uuid.UUID `json:"id"`
	NetworkInternalID  string    `json:"network_internal_id"`
	Content            string    `json:"content"`
	CreatedAt          time.Time `json:"created_at"`
	Author             string    `json:"author"`
	Network            string    `json:"network"`
	Likes              int64     `json:"likes"`
	Reposts            int64     `json:"reposts"`
	ExpectedEngagement float64   `json:"expected_engagement"`
}

func (q *Queries) GetPerformanceDeviationData(ctx context.Context, userID uuid.UUID) ([]GetPerformanceDeviationDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getPerformanceDeviationData, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPerformanceDeviationDataRow
	for rows.Next() {
		var i GetPerformanceDeviationDataRow
		if err := rows.Scan(
			&i.ID,
			&i.NetworkInternalID,
			&i.Content,
			&i.CreatedAt,
			&i.Author,
			&i.Network,
			&i.Likes,
			&i.Reposts,
			&i.ExpectedEngagement,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
